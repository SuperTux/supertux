using System;
using System.IO;
using System.Collections;
using Lisp;

public class TileGroup {
    public string Name;
    public ArrayList Tiles = new ArrayList();

    public void Write(LispWriter writer) {
        writer.StartList("tilegroup");

        writer.Write("name", Name);
        writer.Write("tiles", Tiles);

        writer.EndList("tilegroup");
    }

    public void Parse(Lisp.Parser parser) {
        int d = parser.Depth;
        while(parser.Parse() && parser.Depth >= d) {
            if(parser.Depth == d+1) {
                if(parser.Type != Parser.LispType.SYMBOL)
                    throw new Exception("expected SYMBOL");
                string symbol = parser.SymbolValue;
                parser.Parse();
                switch(symbol) {
                    case "name":
                        Name = parser.StringValue;
                        break;
                    case "tiles":
                        do {
                            if(!Tiles.Contains(parser.IntegerValue))
                                Tiles.Add(parser.IntegerValue);
                        } while(parser.Parse() 
                                && parser.Type == Parser.LispType.INTEGER);
                        break;
                    default:
                        Console.WriteLine("Unknown section " + symbol);
                        break;
                }
            }
        }
    }
}

public class TileSet {
    public ArrayList Tiles = new ArrayList();
    public ArrayList TileGroups = new ArrayList();

    public void Write(string filename) {
        FileStream fs = new FileStream(filename, FileMode.Create);
       
        TextWriter tw = new StreamWriter(fs);
        LispWriter writer = new LispWriter(tw);

        writer.WriteComment("Generated by tiler");
        writer.StartList("supertux-tiles");
        foreach(TileGroup tilegroup in TileGroups) {
            tilegroup.Write(writer);
        }
        foreach(Tile tile in Tiles) {
            if(tile == null)
                continue;
            if(tile.ID >= 0)
                tile.Write(writer);
        }
        writer.EndList("supertux-tiles");
        tw.Close();
        fs.Close();
    }
    
    public void Parse(string filename) {
        FileStream fs = new FileStream(filename, FileMode.Open);
        StreamReader stream = new StreamReader(fs);

        Lisp.Parser parser = new Lisp.Parser(stream);
        parser.Parse();
        if(parser.Type != Parser.LispType.START_LIST)
            throw new Exception("Expected START_LIST");
        parser.Parse();
        if(parser.Type != Parser.LispType.SYMBOL)
            throw new Exception("Expected symbol");
        if(parser.SymbolValue != "supertux-tiles")
            throw new Exception("not a supertux tile files but " +
                    parser.SymbolValue);
        ParseTiles(parser);

        stream.Close();
        fs.Close();
    }

    public void ParseTiles(Lisp.Parser parser) {
        int d = parser.Depth;
        while(parser.Parse() && parser.Depth >= d) {
            if(parser.Depth == d && parser.Type != Parser.LispType.START_LIST) {
                Console.WriteLine("non-cons type in list...");
                continue;
            }

            if(parser.Depth == d+1) {
                if(parser.Type != Parser.LispType.SYMBOL) {
                    throw new Exception("Expected symbol in list element");
                }
                switch(parser.SymbolValue) {
                    case "properties":
                        SkipList(parser);
                        break;
                    case "tilegroup":
                        TileGroup tilegroup = new TileGroup();
                        tilegroup.Parse(parser);
                        TileGroups.Add(tilegroup);
                        break;
                    case "tile":
                        Tile tile = new Tile();
                        tile.Parse(parser);

                        while(tile.ID >= Tiles.Count)
                            Tiles.Add(null);
                        Tiles[tile.ID] = tile;
                        break;
                    default:
                        throw new Exception("Unexpected listentry: " +
                                parser.SymbolValue);
                }
            }
        }
    }

    private void SkipList(Lisp.Parser parser) {
        int d = parser.Depth;
        while(parser.Parse() && parser.Depth >= d)
            ;
    }
}

